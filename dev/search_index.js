var documenterSearchIndex = {"docs":
[{"location":"#Tables.jl-Documentation-1","page":"Home","title":"Tables.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This guide provides documentation around the powerful tables interfaces in the Tables.jl package. Note that the package, and hence, documentation, are geared towards package and library developers who intend to implement and consume the interfaces. Users, on the other hand, benefit from these other packages that provide useful access to table data in various formats or workflows.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"With that said, don't hesitate to open a new issue, even just for a question, or come chat with us on the #data slack channel with question, concerns, or clarifications.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Using-the-Interface-(i.e.-consuming-Tables.jl-sources)-1","page":"Home","title":"Using the Interface (i.e. consuming Tables.jl sources)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"We start by discussing usage of the Tables.jl interfaces, since that can help contextualize implementing them.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"At a high level, Tables.jl provides two powerful APIs for predictably accessing data from any table-like source:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# access data of input table `x` row-by-row\nrows = Tables.rows(x)\n\nfor row in rows\n    # example of getting all values in the row\n    # there are other ways to more efficiently process rows\n    rowvalues = [Tables.getcolumn(row, col) for col in Tables.columnnames(row)]\nend\n\n# access data of input table `x` column-by-column\ncolumns = Tables.columns(x)\n\n# iterate through each column name in table\nfor col in Tables.columnnames(columns)\n    # retrieve entire column by column name\n    # a column is an indexable collection\n    # with known length (i.e. supports\n    # `length(column)` and `column[i]`)\n    column = Tables.getcolumn(columns, col)\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"So we see two high-level functions here, Tables.rows, and Tables.columns.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tables.rows\nTables.columns","category":"page"},{"location":"#Tables.rows","page":"Home","title":"Tables.rows","text":"Tables.rows(x) => Row iterator\n\nAccesses data of input table source x row-by-row by returning a Row iterator. Note that even if the input table source is column-oriented by nature, an efficient generic definition of Tables.rows is defined in Tables.jl to return an iterator of row views into the columns of the input.\n\nThe Tables.Schema of a Row iterator can be queried via Tables.schema(rows), which may return nothing if the schema is unknown. Column names can be queried by calling Tables.columnnames(row) on an individual row. And row values can be accessed by calling Tables.getcolumn(rows, i::Int ) or Tables.getcolumn(rows, nm::Symbol) with a column index or name, respectively.\n\n\n\n\n\n","category":"function"},{"location":"#Tables.columns","page":"Home","title":"Tables.columns","text":"Tables.columns(x) => Columns-compatible object\n\nAccesses data of input table source x by returning a Columns-compatible object, which allows retrieving entire columns by name or index. A retrieved column is an object that is indexable and has a known length, i.e. supports  length(col) and col[i] for any i = 1:length(col). Note that even if the input table source is row-oriented by nature, an efficient generic definition of Tables.columns is defined in Tables.jl to build a Columns- compatible object object from the input rows.\n\nThe Tables.Schema of a Columns object can be queried via Tables.schema(columns), which may return nothing if the schema is unknown. Column names can be queried by calling Tables.columnnames(columns). And individual columns can be accessed by calling Tables.getcolumn(columns, i::Int ) or Tables.getcolumn(columns, nm::Symbol) with a column index or name, respectively.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Home","title":"Home","text":"Given these two powerful data access methods, let's walk through real, albeit somewhat simplified versions of how packages actually use these methods.","category":"page"},{"location":"#Tables.rows-usage-1","page":"Home","title":"Tables.rows usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"First up, let's take a look at the SQLite.jl package and how it uses the Tables.jl interface to allow loading of generic table-like data into a sqlite relational table. Here's the code:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function load!(table, db::DB, tablename)\n    # get input table rows\n    rows = Tables.rows(table)\n    # query for schema of data\n    sch = Tables.schema(rows)\n    # create table using tablename and data schema\n    createtable!(db, tablename, sch)\n    # build insert statement\n    params = chop(repeat(\"?,\", length(sch.names)))\n    stmt = Stmt(db, \"INSERT INTO $tablename VALUES ($params)\")\n    # start a transaction for inserting rows\n    transaction(db) do\n        # iterate over rows in the input table\n        for row in rows\n            # Tables.jl provides a utility function\n            # Tables.eachcolumn, which allows efficiently\n            # applying a function to each column value in a row\n            # it's called with a schema and row, and applies\n            # a user-provided function to the column `val`, index `i`\n            # and column name `nm`. Here, we bind the row values\n            # to our parameterized SQL INSERT statement and then\n            # call `sqlite3_step` to execute the INSERT statement.\n            Tables.eachcolumn(sch, row) do val, i, nm\n                bind!(stmt, i, val)\n            end\n            sqlite3_step(stmt.handle)\n            sqlite3_reset(stmt.handle)\n        end\n    end\n    return\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This is pretty straightforward usage: it calls Tables.rows on the input table source, and since we need the schema to setup the database table, we query it via Tables.schema. We then iterate the rows in our table via for row in rows, and use the convenient Tables.eachcolumn to efficiently apply a function to each value in the row. Note that we didn't call Tables.columnnames or Tables.getcolumn at all, since they're utilized by Tables.eachcolumn itself.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"One wrinkle to consider is the \"unknown schema\" case; i.e. what if our Tables.schema call had returned nothing.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function load!(sch::Nothing, rows, db::DB, tablename)\n    # sch is nothing === unknown schema\n    # start iteration on input table rows\n    state = iterate(rows)\n    state === nothing && return\n    row, st = state\n    # query column names of first row\n    names = Tables.columnnames(row)\n    # partially construct Tables.Schema by at least passing\n    # the column names to it\n    sch = Tables.Schema(names, nothing)\n    # create table if needed\n    createtable!(db, tablename, sch)\n    # build insert statement\n    params = chop(repeat(\"?,\", length(names)))\n    stmt = Stmt(db, \"INSERT INTO $nm VALUES ($params)\")\n    # start a transaction for inserting rows\n    transaction(db) do\n        while true\n            # just like before, we can still use `Tables.eachcolumn`\n            # even with our partially constructed Tables.Schema\n            # to apply a function to each value in the row\n            Tables.eachcolumn(sch, row) do val, i, nm\n                bind!(stmt, i, val)\n            end\n            sqlite3_step(stmt.handle)\n            sqlite3_reset(stmt.handle)\n            # keep iterating rows until we finish\n            state = iterate(rows, st)\n            state === nothing && break\n            row, st = state\n        end\n    end\n    return name\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The strategy taken here is to start iterating the input source, and using the first row as a guide, we make a Tables.Schema object with just the column names, which we can then still pass to Tables.eachcolumn to apply our bind! function to each row value.","category":"page"},{"location":"#Tables.columns-usage-1","page":"Home","title":"Tables.columns usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Ok, now let's take a look at a case utlizing Tables.columns. The following code is taken from the DataFrames.jl Tables.jl implementation:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"getvector(x::AbstractVector) = x\ngetvector(x) = collect(x)\n\n# note that copycols is ignored in this definition (Tables.CopiedColumns implies copies have already been made)\nfromcolumns(x::Tables.CopiedColumns, names; copycols::Bool=true) =\n    DataFrame(AbstractVector[getvector(Tables.getcolumn(x, nm) for nm in names],\n              Index(names),\n              copycols=false)\nfromcolumns(x; copycols::Bool=true) =\n    DataFrame(AbstractVector[getvector(Tables.getcolumn(x, nm) for nm in names],\n              Index(names),\n              copycols=copycols)\n\nfunction DataFrame(x; copycols::Bool=true)\n    # get columns from input table source\n    cols = Tables.columns(x)\n    # get column names as Vector{Symbol}, which is required\n    # by core DataFrame constructor\n    names = collect(Symbol, Tables.columnnames(cols))\n    return fromcolumns(cols, names; copycols=copycols)\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"So here we have a generic DataFrame constructor that takes a single, untyped argument, calls Tables.columns on it, then Tables.columnnames to get the column names. It then passes the Columns-compatible object to an internal function fromcolumns, which dispatches on a special kind of Columns object called a Tables.CopiedColumns, which wraps any Columns object that has already had copies of its columns made, and are thus safe for the columns-consumer to assume ownership of (this is because DataFrames.jl, by default makes copies of all columns upon construction). In both cases, individual columns are collected in Vector{AbstractVector}s by calling Tables.getcolumn(x, nm) for each column name. A final note is the call to getvector on each column, which ensures each column is materialized as an AbstractVector, as is required by the DataFrame constructor.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note in both the rows and columns usages, we didn't need to worry about the natural orientation of the input data; we just called Tables.rows or Tables.columns as was most natural for the table-specific use-case, knowing that it will Just Work™️.","category":"page"},{"location":"#Tables.jl-Utilities-1","page":"Home","title":"Tables.jl Utilities","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Before moving on to implementing the Tables.jl interfaces, we take a quick break to highlight some useful utility functions provided by Tables.jl:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tables.rowtable\nTables.columntable\nTables.namedtupleiterator\nTables.datavaluerows\nTables.nondatavaluerows\nTables.table\nTables.matrix\nTables.eachcolumn\nTables.materializer\nTables.columnindex\nTables.columntype","category":"page"},{"location":"#Tables.rowtable","page":"Home","title":"Tables.rowtable","text":"Tables.rowtable(x) => Vector{NamedTuple}\n\nTake any input table source, and produce a Vector of NamedTuples, also known as a \"row table\". A \"row table\" is a kind of default table type of sorts, since it satisfies the Tables.jl row interface naturally, i.e. a Vector naturally iterates its elements, and NamedTuple satisifes the Row interface by default (allows indexing value by index, name, and getting all names).\n\n\n\n\n\n","category":"function"},{"location":"#Tables.columntable","page":"Home","title":"Tables.columntable","text":"Tables.columntable(x) => NamedTuple of Vectors\n\nTakes any input table source x and returns a NamedTuple of Vectors, also known as a \"column table\". A \"column table\" is a kind of default table type of sorts, since it satisfies the Tables.jl column interface naturally.\n\n\n\n\n\n","category":"function"},{"location":"#Tables.namedtupleiterator","page":"Home","title":"Tables.namedtupleiterator","text":"Tables.namedtupleiterator(x)\n\nPass any table input source and return a NamedTuple iterator\n\n\n\n\n\n","category":"function"},{"location":"#Tables.datavaluerows","page":"Home","title":"Tables.datavaluerows","text":"Tables.datavaluerows(x) => NamedTuple iterator\n\nTakes any table input x and returns a NamedTuple iterator that will replace missing values with DataValue-wrapped values; this allows any table type to satisfy the TableTraits.jl  Queryverse integration interface by defining: \n\nIteratorInterfaceExtensions.getiterator(x::MyTable) = Tables.datavaluerows(x)\n\n\n\n\n\n","category":"function"},{"location":"#Tables.nondatavaluerows","page":"Home","title":"Tables.nondatavaluerows","text":"Tables.nondatavaluerows(x)\n\nTakes any Queryverse-compatible NamedTuple iterator source and  converts to a Tables.jl-compatible Row iterator. Will automatically unwrap any DataValues, replacing NA with missing. Useful for translating Query.jl results back to non-DataValue-based tables.\n\n\n\n\n\n","category":"function"},{"location":"#Tables.table","page":"Home","title":"Tables.table","text":"Tables.table(m::AbstractMatrix; [header::Vector{Symbol}])\n\nWrap an AbstractMatrix (Matrix, Adjoint, etc.) in a MatrixTable, which satisfies the Tables.jl interface. This allows accesing the matrix via Tables.rows and Tables.columns. An optional keyword argument header can be passed as a Vector{Symbol} to be used as the column names. Note that no copy of the AbstractMatrix is made.\n\n\n\n\n\n","category":"function"},{"location":"#Tables.matrix","page":"Home","title":"Tables.matrix","text":"Tables.matrix(table; transpose::Bool=false)\n\nMaterialize any table source input as a Matrix. If the table column types are not homogenous, they will be promoted to a common type in the materialized Matrix. Note that column names are ignored in the conversion. By default, input table columns will be materialized as corresponding matrix columns; passing transpose=true will transpose the input with input columns as matrix rows.\n\n\n\n\n\n","category":"function"},{"location":"#Tables.eachcolumn","page":"Home","title":"Tables.eachcolumn","text":"Tables.eachcolumn(f, sch, row, args...)\nTables.eachcolumn(Tables.columns(x))\n\nThe first definition takes a function f, table schema sch, a row object (that satisfies the Row interface), and any other args...; it generates calls to get the value for each column in the row (Tables.getcolumn(row, nm)) and then calls f(val, col, name, args...), where f is the user-provided function, val is a row's column value, col is the column index as an Int, and name is the row's column name as a Symbol.\n\nWhile the first definition applies to a Row object, the 2nd definition applies to a Columns object, which simply iterates each column. For example, one could get every column of a Columns object by doing:\n\nvectors = [col for col in Tables.eachcolumn(Tables.columns(x))]\n\n\n\n\n\n","category":"function"},{"location":"#Tables.materializer","page":"Home","title":"Tables.materializer","text":"Tables.materializer(x) => Callable\n\nFor a table input, return the \"sink\" function or \"materializing\" function that can take a Tables.jl-compatible table input and make an instance of the table type. This enables \"transform\" workflows that take table inputs, apply transformations, potentially converting the table to a different form, and end with producing a table of the same type as the original input. The default materializer is Tables.columntable, which converts any table input into a NamedTuple of Vectors.\n\n\n\n\n\n","category":"function"},{"location":"#Tables.columnindex","page":"Home","title":"Tables.columnindex","text":"given names and a Symbol name, compute the index (1-based) of the name in names\n\n\n\n\n\nTables.columnindex(table, name)\n\nReturn the column index (1-based) of a column by name in a table with a known schema; returns 0 if name doesn't exist in table\n\n\n\n\n\n","category":"function"},{"location":"#Tables.columntype","page":"Home","title":"Tables.columntype","text":"given tuple type and a Symbol name, compute the type of the name in the tuples types\n\n\n\n\n\nTables.columntype(table, name)\n\nReturn the column type of a column by name in a table with a known schema; returns Union{} if name doesn't exist in table\n\n\n\n\n\n","category":"function"},{"location":"#Implementing-the-Interface-(i.e.-becoming-a-Tables.jl-source)-1","page":"Home","title":"Implementing the Interface (i.e. becoming a Tables.jl source)","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Now that we've seen how one uses the Tables.jl interface, let's walk-through how to implement it; i.e. how can I make my custom type valid for Tables.jl consumers?","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The interface to becoming a proper table is straightforward:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Required Methods Default Definition Brief Description\nTables.istable(table)  Declare that your table type implements the interface\nOne of:  \nTables.rowaccess(table)  Declare that your table type defines a Tables.rows(table) method\nTables.rows(table)  Return a Row iterator from your table\nOr:  \nTables.columnaccess(table)  Declare that your table type defines a Tables.columns(table) method\nTables.columns(table)  Return a Columns-compatible object from your table\nOptional methods  \nTables.schema(x) Tables.schema(x) = nothing Return a Tables.Schema object from your Row iterator or Columns object; or nothing for unknown schema\nTables.materializer(table) Tables.columntable Declare a \"materializer\" sink function for your table type that can construct an instance of your type from any Tables.jl input","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Based on whether your table type has defined Tables.rows or Tables.columns, you then ensure that the Row iterator or Columns object satisfies the respective interface:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tables.Row\nTables.Columns","category":"page"},{"location":"#Tables.Row","page":"Home","title":"Tables.Row","text":"Tables.Row\n\nAn interface type that represents a single row of a table, with column values retrievable by name or index. The high-level Tables.rows function returns a Row-compatible iterator from any input table source.\n\nAny object implements the Row interface, by satisfying the following: | Required Methods                                       | Default Definition        | Brief Description                                                                                                                                                | |––––––––––––––––––––––––––––|–––––––––––––-|–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––| | Tables.getcolumn(row, i::Int)                        | getfield(row, i)          | Retrieve a column value by index                                                                                                                                 | | Tables.getcolumn(row, nm::Symbol)                    | getproperty(row, nm)      | Retrieve a column value by name                                                                                                                                  | | Tables.columnnames(row)                              | propertynames(row)        | Return column names for a row as an indexable collection                                                                                                         | | Optional methods                                   |                           |                                                                                                                                                                  | | Tables.getcolumn(row, ::Type{T}, i::Int, nm::Symbol) | Tables.getcolumn(row, nm) | Given a column type T, index i, and column name nm, retrieve the column value. Provides a type-stable or even constant-prop-able mechanism for efficiency. |\n\nNote that custom row types shouldn't subtype Row, as it is purely an interface type to help document the Tables.jl API. See the Tables.AbstractRow type for a type to potentially subtype to gain useful default behaviors.\n\n\n\n\n\n","category":"type"},{"location":"#Tables.Columns","page":"Home","title":"Tables.Columns","text":"Tables.Columns\n\nAn interface type defined as an ordered set of columns that support retrieval of individual columns by name or index. A retrieved column must be an indexable collection with known length, i.e. an object that supports length(col) and col[i] for any i = 1:length(col). The high-level Tables.columns function returns a Columns-compatible object from any input table source.\n\nAny object implements the Columns interface, by satisfying the following: | Required Methods                                         | Default Definition          | Brief Description                                                                                                                                            | |–––––––––––––––––––––––––––––|––––––––––––––-|–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––| | Tables.getcolumn(table, i::Int)                        | getfield(table, i)          | Retrieve a column by index                                                                                                                                   | | Tables.getcolumn(table, nm::Symbol)                    | getproperty(table, nm)      | Retrieve a column by name                                                                                                                                    | | Tables.columnnames(table)                              | propertynames(table)        | Return column names for a table as an indexable collection                                                                                                   | | Optional methods                                     |                             |                                                                                                                                                              | | Tables.getcolumn(table, ::Type{T}, i::Int, nm::Symbol) | Tables.getcolumn(table, nm) | Given a column eltype T, index i, and column name nm, retrieve the column. Provides a type-stable or even constant-prop-able mechanism for efficiency. |\n\nNote that table sources shouldn't subtype Columns, as it is purely an interface type to help document the Tables.jl API. See the Tables.AbstractColumns type for a type to potentially subtype to gain useful default behaviors.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Home","title":"Home","text":"Though the strict requirements for Row and Columns are minimal (just getcolumn and columnnames), you may desire additional behavior for your row or columns types (and you're implementing them yourself). For convenience, Tables.jl defines the Tables.AbstractRow and Tables.AbstractColumns abstract types, to allow subtyped custom types to inherit convenient behavior, such as indexing, iteration, and property access, all defined in terms of getcolumn and columnnames.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Tables.AbstractRow\nTables.AbstractColumns","category":"page"},{"location":"#Tables.AbstractRow","page":"Home","title":"Tables.AbstractRow","text":"Tables.AbstractRow\n\nAbstract type provided to allow custom row types to inherit useful and required behavior. Note that this type is for convenience for table source authors to provide useful default behavior to their Row object, and not to be used or relied upon by sink authors to dispatch on; i.e. not all Row objects will inherit from Tables.AbstractRow.\n\nInterface definition:\n\nRequired Methods Default Definition Brief Description\nTables.getcolumn(row, i::Int) getfield(row, i) Retrieve a column value by index\nTables.getcolumn(row, nm::Symbol) getproperty(row, nm) Retrieve a column value by name\nTables.columnnames(row) propertynames(row) Return column names for a row as an indexable collection\nOptional methods  \nTables.getcolumn(row, ::Type{T}, i::Int, nm::Symbol) Tables.getcolumn(row, nm) Given a column type T, index i, and column name nm, retrieve the column value. Provides a type-stable or even constant-prop-able mechanism for efficiency.\n\nWhile custom row types aren't required to subtype Tables.AbstractRow, benefits of doing so include:\n\nIndexing interface defined (using getcolumn); i.e. row[i] will return the column value at index i\nProperty access interface defined (using columnnames and getcolumn); i.e. row.col1 will retrieve the value for the column named col1\nIteration interface defined; i.e. for x in row will iterate each column value in the row\nA default show method\n\nThis allows the custom row type to behave as close as possible to a builtin NamedTuple object.\n\n\n\n\n\n","category":"type"},{"location":"#Tables.AbstractColumns","page":"Home","title":"Tables.AbstractColumns","text":"Tables.AbstractColumns\n\nAbstract type provided to allow custom table types to inherit useful and required behavior. Note that this type is for convenience for table source authors to provide useful default behavior to their Columns object, and not to be used or relied upon by sink authors to dispatch on; i.e. not all Columns objects will inherit from Tables.AbstractColumns.\n\nInterface definition:\n\nRequired Methods Default Definition Brief Description\nTables.getcolumn(table, i::Int) getfield(table, i) Retrieve a column by index\nTables.getcolumn(table, nm::Symbol) getproperty(table, nm) Retrieve a column by name\nTables.columnnames(table) propertynames(table) Return column names for a table as an indexable collection\nOptional methods  \nTables.getcolumn(table, ::Type{T}, i::Int, nm::Symbol) Tables.getcolumn(table, nm) Given a column eltype T, index i, and column name nm, retrieve the column. Provides a type-stable or even constant-prop-able mechanism for efficiency.\n\nWhile custom table types aren't required to subtype Tables.AbstractColumns, benefits of doing so include:\n\nIndexing interface defined (using getcolumn); i.e. tbl[i] will retrieve the column at index i\nProperty access interface defined (using columnnames and getcolumn); i.e. tbl.col1 will retrieve column named col1\nIteration interface defined; i.e. for col in table will iterate each column in the table\nA default show method\n\nThis allows a custom table type to behave as close as possible to a builtin NamedTuple of vectors object.\n\n\n\n\n\n","category":"type"},{"location":"#","page":"Home","title":"Home","text":"As an extended example, let's take a look at some code defined in Tables.jl for treating AbstractMatrixs as tables.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"First, we define a special MatrixTable type that will wrap an AbstractMatrix, and allow easy overloading for the  Tables.jl interface.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"struct MatrixTable{T <: AbstractMatrix} <: Tables.AbstractColumns\n    names::Vector{Symbol}\n    lookup::Dict{Symbol, Int}\n    matrix::T\nend\n# declare that MatrixTable is a table\nTables.istable(::Type{<:MatrixTable}) = true\n# getter method on stored column names\nnames(m::MatrixTable) = getfield(m, :names)\n# schema is column names and types\nTables.schema(m::MatrixTable{T}) where {T} = Tables.Schema(names(m), fill(eltype(T), size(getfield(m, :matrix), 2)))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here we defined Tables.istable for all MatrixTable types, signaling that my type implements the Tables.jl interfaces. We also defined Tables.schema by pulling the column names out that we stored, and since AbstractMatrix have a single eltype, we repeat it for each column. Note that defining Tables.schema is optional on tables; by default, nothing is returned and Tables.jl consumers should account for both known and unknown schema cases. It tends to allow consumers to have certain optimizations when they can know the types of all columns upfront (and if the # of columns isn't too large) to generate more efficient code.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now, in this example, we're actually going to have MatrixTable implement both Tables.rows and Tables.columns methods itself, i.e. it's going to return itself from those functions, so here's first how we make our MatrixTable a valid Columns object:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# column interface\nTables.columnaccess(::Type{<:MatrixTable}) = true\nTables.columns(m::MatrixTable) = m\n# required Columns object methods\nTables.getcolumn(m::MatrixTable, ::Type{T}, col::Int, nm::Symbol) where {T} = getfield(m, :matrix)[:, col]\nTables.getcolumn(m::MatrixTable, nm::Symbol) = getfield(m, :matrix)[:, getfield(m, :lookup)[nm]]\nTables.getcolumn(m::MatrixTable, i::Int) = getfield(m, :matrix)[:, i]\nTables.columnnames(m::MatrixTable) = names(m)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We define columnaccess for our type, then columns just returns the MatrixTable itself, and then we define the three getcolumn methods and columnnames. Note the use of a lookup Dict that maps column name to column index so we can figure out which column to return from the matrix. We're also storing the column names in our names field so the columnnames implementation is trivial. And that's it! Literally! It can now be written out to a csv file, stored in a sqlite or other database, converted to DataFrame or JuliaDB table, etc. Pretty fun.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"And now for the Tables.rows implementation:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"# declare that any MatrixTable defines its own `Tables.rows` method\nrowaccess(::Type{<:MatrixTable}) = true\n# just return itself, which means MatrixTable must iterate `Row`-compatible objects\nrows(m::MatrixTable) = m\n# the iteration interface, at a minimum, requires `eltype`, `length`, and `iterate`\n# for `MatrixTable` `eltype`, we're going to provide a custom row type\nBase.eltype(m::MatrixTable{T}) where {T} = MatrixRow{T}\nBase.length(m::MatrixTable) = size(getfield(m, :matrix), 1)\n\nBase.iterate(m::MatrixTable, st=1) = st > length(m) ? nothing : (MatrixRow(st, m), st + 1)\n\n# a custom Row type; acts as a \"view\" into a row of an AbstractMatrix\nstruct MatrixRow{T} <: Tables.AbstractRow\n    row::Int\n    source::MatrixTable{T}\nend\n# required `Row` interface methods (same as for `Columns` object before)\ngetcolumn(m::MatrixRow, ::Type, col::Int, nm::Symbol) =\n    getfield(getfield(m, :source), :matrix)[getfield(m, :row), col]\ngetcolumn(m::MatrixRow, i::Int) =\n    getfield(getfield(m, :source), :matrix)[getfield(m, :row), i]\ngetcolumn(m::MatrixRow, nm::Symbol) =\n    getfield(getfield(m, :source), :matrix)[getfield(m, :row), getfield(getfield(m, :source), :lookup)[nm]]\ncolumnnames(m::MatrixRow) = names(getfield(m, :source))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Here we start by defining Tables.rowaccess and Tables.rows, and then the iteration interface methods, since we declared that a MatrixTable itself is an iterator of Row-compatible objects. For eltype, we say that a MatrixTable iterates our own custom row type, MatrixRow. MatrixRow subtypes Tables.AbstractRow, which has the same required interface as a Row object, but also provides interface implementations for several useful behaviors (indexing, iteration, property-access, etc.); essentially it makes our custom MatrixRow type more convenient to work with.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Implementing the Row/Tables.AbstractRow interface is straightfoward, and very similar to our implementation of Columns previously (i.e. the same methods for getcolumn and columnnames).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"And that's it. Our MatrixTable type is now a fully fledged, valid Tables.jl source and can be used throughout the ecosystem. Now, this is obviously not a lot of code; but then again, the actual Tables.jl interface implementations tend to be fairly simple, given the other behaviors that are already defined for table types (i.e. table types tend to already have a getcolumn like function defined).","category":"page"}]
}
